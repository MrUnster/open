# set - содержит не повторяющиеся элементы в случайном порядке. НЕ ИНДЕКСИРУЕТСЯ
set.update(other, ...); set |= other | ... - объединение.
set.intersection_update(other, ...); set &= other & ... - пересечение.
set.difference_update(other, ...); set -= other | ... - вычитание.
set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в множестве.
set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
set.clear() - очистка множества.
set.copy() - возвращает копию множества.


# dict - неупорядоченные коллекции произвольных объектов с доступом по ключу. Ключем может являться только ХЭШИРУЕМЫЙ тип данных (любое число, строка, кортеж)
dict.clear() - очищает словарь.
dict.copy() - возвращает копию словаря.
dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).
dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
dict.items() - возвращает пары (ключ, значение).
dict.keys() - возвращает ключи в словаре.
dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).
dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
dict.values() - возвращает значения в словаре.


# deque - двусторонняя очередь (стек)
from collections import deque
Deque.copy() - возвращает копию очереди.
Deque.clear() - очищает очередь.
Deque.append(x) - добовление элемента в конец очереди.
Deque.appendleft(x) - добовление элемента в начало очереди.
Deque.count(x) - подсчитывает количество элементов контейнера deque(), равное значению x.
Deque.extend(iterable) - добовленяет элементы из итерируемого аргумента в конец очереди.
Deque.extendleft(iterable) - добовленяет элементы из итерируемого аргумента в начало очереди.
Deque.index(x[, start[, stop]]) - вернет позицию (индекс) первого совпадения значения аргумента x в контейнере deque(), расположенного после необязательного аргумента start и до необязательного аргумента stop.
Deque.insert(i, x) - ставляет значение аргумента x в позицию i контейнера deque().
Deque.pop() - удаляет и возвращает элемент с конца контейнера deque(). Если элементы отсутствуют, возникает ошибка IndexError.
Deque.popleft() - удаляет и возвращает элемент с начала контейнера deque(). Если элементы отсутствуют, возникает ошибка IndexError.
Deque.remove(value) - удаляет первое вхождение значения value в контейнер deque(). Если значение value не найдено, возникает ошибка IndexError.


# Увеличение глубины рекурсии
import sys
sys.setrecursionlimit(x) - устанавливает глубину рекурсии в размере x.


# Алгоритм Манакера для поиска максивального полиндрома в строке O(n)
[сайт](https://habr.com/ru/articles/653617/)
``` python
def Manacher_odd(s: str) -> str:
    n = len(s)
    h = [0] * n
    C = R = 0
    besti, bestj = 0, 0
    for i in range(n):
        # если находимся внутри левого полигона
        if i < C + R:
            j = h[C-(i-C)]
            if j < C + R - i:
                h[i] = j
                continue
            elif j > C + R - i:
                h[i] = C + R - i
                continue
        else:
            j = 0
        # i - текущий центр, j - текущий радиус, h[i] - полигон максимальной длинны с центром i
        while i-j > 0 and i+j<n-1 and s[i-j-1] == s[i+j+1]:
            j += 1
        h[i] = j
        # переносим левый полигон
        if i + j > C + R:
            C, R = i, j
        # сохраняем полигон максимальной длинны
        if j > bestj:
            besti, bestj = i, j
    return s[besti-bestj : besti+bestj+1]

def Manacher(s: str) -> str:
    return Manacher_odd('|'+'|'.join(s)+'|').replace('|', '')
```
